# XPとは何か

* エクストリームプログラミング(XP)はソーシャルチェンジ
* XPとは、以前はうまくいっていたかもしれないが、今では最高の仕事のじゃなになっている風習やパターンを手放すこと
* 良好なビジネスは、良好な人間関係によってもたらされる。
    * 生産性や自信はコーディングや仕事だけでなく、仕事場の人間関係とも結びついている。成功には、優れた技術力と良好な人間関係が必要
    * XPはその両方を扱っている
* XPは、プログラミング技法、明確なコミュニケーション、チームワークなどを巧みに利用して、これまでに想像すらできなかったことを実現するためのソフトウェア開発のスタイル
    * XPには、以下のことが含まれる。
        * コミュニケーション、フィードバック、シンプリシティ、勇気、リスペクトの価値に基づいたソフトウェアの開発の哲学
        * ソフトウェア開発の改善に有効であることが実証された複数のプラクティス。これらは相互に補完して、それぞれの効果を高める。プラクティスは、価値を表現するために選ばれたものたちである。
        * 補完的な原則。価値をプラクティスに変換するための知的な技法。問題に対応できるプラクティスがない時に役に立つ。
        * これらの価値やプラクティスを共有するコミュニティー。

XPとは、ソフトウェアを一緒に開発する人たちが高みに至るまでの改善の道である。他の方法論とは、以下の点で区別される。

* 開発サイクルが短期間である。それにより、迅速で具体的で継続的なフィードバックがもたらされる。
* 計画手法がインクリメンタルである。それにより、プロジェクトの期間中に発展していく全体計画を素早く作成できる。
* 機能の実装スケジュールが柔軟である。それにより、ビジネスニーズの変化に対応できる。
* 開発の進捗状況を把握したり、システムを発展させたり、早期に血管を捕捉したりするために、プログラマー、顧客、テスターたちが書いた自動テストを信頼している。
* システムの構造や意図を伝えるために、口頭でのコミュニケーション、テスト、ソースコードを信頼している。
* システムが存在する鍵t理設計を続けるために、進化的な設計プロセスを信頼している。
* 普通の才能を持った熱心で積極的な個人がお互いに密接に協力しあうことを信頼している。
* チームメンバーの短期的な同期とプロジェクトの長期的な利益の量穂につながるプラクティスを信頼している。

XPは、以下のように説明できる。

* XPは、軽量である。XPでは、顧客にバリューをもたらすために必要なことだけを実施する。
* XPは、ソフトウェア開発の制約に対応するための方法論である。

### 自分や他人に思いやりのある接し方をすれば、生産性が高まる

* 若い頃に身につけた習慣、態度、価値は、当時はうまくいったかもしれないが、現在では、必ずしも最善の選択とは言えない

* スケジュールの遅延
    * XPのリリースサイクルは短期間(長くても数ヶ月)なので、遅延の範囲は限定されている
    * リリースの期間中は、１週間のイテレーションで顧客が要求したフィーチャーを作り、進捗を細かくフィードバックする
    * イテレーションの期間中は、短時間のタスクで計画を立てるため、チームはそのサイクルの中で問題を解決できる
    * XPでは、優先順位の高いフィーチャーから実装するので、リリースできなかったりフィーチャーの重要度は低い
* プロジェクトの打ち切り
    * XPでは、ビジネスに意味をもたらす最小限のリリースをチームのビジネス担当に選択してもらう
    * それにより、デプロイ前に道を誤ることは少なくなり、ソフトッウェアのバリューは最大化する
* システムの劣化
    * XPでは、包括的な自動テストスイートを作成/保守する
    * 変更が(１日になんども)発生するたびに自動テストが実行/再実行され、ベースラインとなる品質が確保される
    * XPでは、システムを常にデプロイ可能な状態に保つ。問題が蓄積することは許されない
* 欠陥率の高さ
    * XPでは、プログラマーが各機能ごとのテストと、顧客が各プロがラムフィーチャーことのテストの両方の観点からテストする
* ビジネスの誤解
    * XPでは、ビジネス担当をチームのファーストクラスのメンバーとする
    * プロジェクトの使用を開発の中で継続的に洗練するため、顧客やチームの学びをソフトウェアに反映することができる
* ビジネスの変化
    * XPでは、リリースサイクルを短くしている
    * そのため、一つのリリースの開発期間で発生する返納は小さい
    * リリースの期間中に顧客は、まだ完成していない機能と新機能を自由に入れ替えることができる
    * 従って、新しい機能なのか数年前からある機能なのか気づかないまま、チームが作業することもある。</td></tr>
* 必要のないフィーチャーばかり
    * XPでは、優先順位の高いタスクだけを扱う
* 人材の流出
    * XPでは、プログラマーの見積もりを重視したりしている
    * 誰が見積もりをするのか、誰が見積もりを変更するのかは、明確にルールで決められている
    * 従って、明らかに不可能なことを依頼されて、プログラマーが不満を募らせるようなことは少ない
    * XPでは、チームの中で人間関係を築くことが推奨されている
    * 仕事に対する不満の多くは、孤独が原因だから
    * XPには、新しいチームメンバーが参加した時の明確なモデルが用意されている

### 理想的には明確なゴールと実行計画を共有していることを前提とする

* XPでは、あなたが自身の成長、スキルの向上、人間関係の改善を望んでいることを前提とする
* XPでは、これらのゴールを達成するために、あなたが変化を引き起こすつもりがあることを前提とする

## XPとは何か

* XPとは、効果のない技術的/社会的な古い習慣を捨て、効果のある新しい習慣を選ぶことである。
* XPとは、自分が今日やるべきことを十分に理解することである。
* XPとは、明日をよりよくしようとすることである。
* XPとは、チームのゴールに貢献した自分を評価することである。
* XPとは、ソフトウェア開発で人間としての欲求を満たすことである。

# 運転を学ぶ

* 変化は何れにしても起きる
    * 問題はむしろ、我々が変化に対応できないことにある

# 価値

* 「トラブルに巻き込まれる原因は、何かを知らないことではない。よく知らないのに、知っていると勘違いすることである」
* 全員がチームにとって大切なことはコミュニケーション、シンプリシティ、フィードバック、勇気、リスペクト

## コミュニケーション（Communication）

* チームによるソフトウェア開発で最も重要なのは、コミュニケーション
* 開発中に問題が発生したときには、すでに誰かが解決策を知っていることが多い
* だが、その情報は変更する権限のある人には伝わらない。
* 問題に遭遇したときは、それがコミュニケーションの欠如によるものかどうかを自問

## シンプリシティ（Simplicity）

* コミュニケーションによって、時間的猶予のある要件を削除すれば、それがシンプリシティの達成につながる
* シンプリシティを達成すれば、必要なコミュニケーションも少なくなる

## フィードバック（Feedback）

* 変化は避けられないものであり、変化がフィードバックを必要にする
* 一時的な完成に期待するよりも、常に改善を続ける
    * そうすれば、フィードバックを使って、ゴールに近づくことができる
    
フィードバックには、以下のようなさまざまな形式がある。

* アイデアに対するあなたやチームメイトの意見
* アイデアを実装したときのコードの状態
* テストは書きやすいか
* テストは実行できているか
* 実現したアイデアがうまく機能しているか

## 勇気（Courage）

* 勇気とは恐怖に直面したときの効果的な行動のことである。
* 時として勇気は、忍耐となって現れる
* 問題があることがわかっていても、何が問題かがわからなければ、明確にわかるまで勇気を持って待機すべき

## リスペクト（Respect）

* チームメンバーがお互いに関心がなく、何をしているかを気にもとめないようであれば、XPはうまくいかない

## その他の価値

* 最も重要なのは、チームの振る舞いをチームの価値に合わせること
* その他の重要な価値としては、安全性、セキュリティ、予測可能性、生活の質など

# 原則

* ドキュメントよりも会話の方が価値があることが`人間性`の原則によって示されている
* ドキュメントによるコミュニケーションは本質的にムダが多い。多くの人に情報は伝わるかもしれないが、コミュニケーションは本質的にムダが多い。
    * 多くの人に情報は伝わるかもしれないが、ドキュメントによるコミュニケーションは一方的
    * ドキュメントによるコミュニケーションは、事実として受け止められるか、真っ向から否定されるかのいずれかになりやすい

## 人間性（Humanity）

* ソフトウェア開発は人間の欲求を満たしていない
    * 人間の弱さを認めていない
    * 人間の強さを活用していない

## 相互利益（Mutual Benefit）

* アドバイスを聞き入れてもらうには、対象とする問題よりも多くの問題を解決する必要がある。

## 改善（Improvement）

* インクリメンタルな設計</strong>によってシステムの設計を洗練していけば、改善をうまく機能させることができる
* 実際の設計は理想を完璧に反映したものには決してならないが、両者を日々近づけていくことならできる

## 多様性（Diversity）

* みんながよく似ているソフトウェア開発チームは、居心地はよいかもしれないが、機能的ではない
* チームは、問題や落とし穴を見つめたり、問題を解決する方法を複数考えたり、解決策を実現したりするために、さまざまなスキル、考え方、視点を組み合わせる必要がある
* 「これを解決するには２つの方法がある」という意味での衝突
* 設計のアイデアが２つあれば、それは問題ではなく機会

## ふりかえり（Reflection）

* どうやって仕事をしているのか、なぜ仕事をしているのか
* なぜ成功したのか、なぜ失敗したのか

## 流れ（Flow）

* XPのプラクティスは、不連続のフェーズよりも安定した流れに適している
* 流れの原則では、改善のために小さなバリューを何度もデプロイすることを提唱している。
* １日１回（できれば数回）機能を正しく動作させるべき

## 機会（Opportunity）

* 問題を変化の機会と考える
* 「サバイバル」の姿勢では、その場を切り抜けるための問題解決しかできない
* 高みに到達するには、問題を学習や改善の機会に変換しなければいけない
* エクストリームになるというのは、それぞれの問題を個人の成長、人間関係の深化、ソフトウェアの改善などの機会に意識的に変換することでもある。

## 冗長性（Redundancy）

* 欠陥はムダの排除に有効な信頼関係を蝕む
* 冗長性はムダにつながる可能性がある反面、目的の達成に必要な冗長性は排除しないように気をつける

## 失敗（Failure）

* うまく成功できなければ、失敗する
* ストーリーを実装する３つの方法のうち、どれを選んだらいいかわからないなら３つすべてを試す

## 品質（Quality）

* 品質を犠牲にするのは、効果的なコントロール方法ではない
* 品質は制御変数ではない。低品質を受け入れることで、プロジェクトが速くなることはない
* 高品質を要求することで、プロジェクトが遅くなることもない
    * むしろ品質を高めることで、デリバリーが高速になることが多い

## ベイビーステップ（Baby Steps）

* 大きな変更は、大きなステップでやりたくなるものである
* 重大な変更を一気に行うのは危険
* 変更は不安を伴う。不安を伴えば、人間は変更を素早くやろうとする
* `あなたができる最も小さなことで、正しい方向がすぐにわかるもの`から進める

## 責任の引き受け（Accepted Responsibility）

* 責任は割り当てるのではなく、引き受けることしかできない
* 誰かがあなたに責任を担わせようとしても、責任を持つかどうかを選ぶのはあなたである。
* 責任には権限が伴わなければいけない
    * このバランスがとれていないと、チームのコミュニケーションが破綻してしまう

## 結論

* プラクティスを深く理解したり、目的に適したプラクティスが見つからずに補助的なプラクティスを作ったりするときには、原則を使えばいい
* プラクティスは（「コードを変更する前にテストを書く」のように）明確で客観的に説明されている

# プラクティス

* プラクティスとは、XPチームが日常的に行うもの
* コミュニケーションであり、フィードバックを獲得するものであり、システムをシンプルにするものであり、エラーを補足するものであり、ペアプログラミングには大きな意味がある
* プラクティスは状況に依存する。状況が変われば、条件に合わせてプラクティスを選ぶことになる
* ただし、状況が変わっても、価値を変えてはいけない

# 主要プラクティス

* XPを適用してソフトウェア開発を改善するときに、安全に始めるためのプラクティス

## 全員同席（Sit Together）

* チーム全体が入れる十分な広さのオープンスペースで開発する
    * 近くに小さなプライベート空間を用意するなど、チームメンバーのプライバシーや「自分だけの」スペースといった欲求を満たせるようにすること
* チームの準備ができる前に、パーティションの壁を外すは逆効果
* チームメンバーの安心感が個人の小さなスペースと結び付いている場合は、それを集団で達成する安心感と置き換えない限り、怒りや抵抗を招いてしまう

## チーム全体（Whole Team）

* プロジェクトの成功に必要なスキルや視点を持った人たちをチームに集めること
* これは昔からある「クロスファンクショナルチーム」の考え

## 情報満載のワークスペース(Informative Workspace)

* 仕事の内容がわかるようなワークスペースを作る
* プロジェクトに関心のある人がチームのスペースを見たときに、15秒で状況を把握できるようにすべき
* ストーリーカードを壁に貼り付けて、このプラクティスを部分的に実践しているチームも多い
    * カードを空間的に分類すれば、情報をすばやく伝達できる

## いきいきとした仕事（Energized Work）

* ソフトウェア開発は洞察力のゲーム
* 洞察力は、準備の整った、休息のとれた、リラックスした精神から生み出される
* 病気のときは休息と回復に努め、自分とチームをリスペクト
    * 静養こそがいきいきとした仕事に戻る近道
* 病気による生産性の低下からチームを守ることにもつながる

## ペアプログラミング（Pair Programming）

* 同じマシンを前にした2人で、本番用のすべてのプログラムを書くこと
* 2人が並んで楽に座れるようにマシンを設置すること
* 入力しやすいようにキーボードやマウスを適宜移動させること
* ペアプログラミングとは、2人でプログラミング(および分析、設計、テスト)とプログラムの改良を同時に行うやりとりのこと
* ペアプログラミングでは、以下のようなことをする
    * お互いにタスクに集中する。
    * システムの改良について意見を出し合う。
    * アイデアを明確にする。
    * パートナーがハマったら主導権を握り、相手の失望感を軽減させる。
    * お互いにチームのプラクティスの説明責任を果たせるようにする。

## ペアとパーソナルスペース

* うまくやるには、お互いのパーソナルスペースをリスペクトしなければいけない

## ストーリー（Stories）

* 顧客に見える機能の単位を使って計画する
    * たとえば、「これまでのレスポンスタイムで5倍のトラフィックを処理する」「よく使う番号に2クリックの短縮を提供する」など
    * ストーリーが書けたら、必要な開発工数をすぐに見積もる
* ストーリーは早めに見積もる
    * 要件に関するその他のプラクティスとストーリーとの大きな違いはここ
* ストーリーには簡潔な記述や絵だけでなく、短い名前もつけること
* ストーリーはインデックスカードに書いて、人通りの多い壁に貼り付けること
    * ストーリーとコンピューターで処理する試みをいくつも見てきたが、壁に貼ったカードほど扱いやすいものはない
    
## 週次サイクル（Weekly Cycle）

* 1週間分の仕事の計画をまとめて立てる
* そして、週のはじめにミーティングを入れること
* ミーティングでは、以下のことを行う
    * 先週の進捗が期待していた進捗と合致しているかなど、これまでの進捗状況をレビューする。
    * 今週実装する1週間分のストーリーを顧客に選んでもらう。
    * ストーリーをタスクに分解する。チームメンバーはタスクにサインアップして、それぞれのタスクを見積もる。
        * 週のはじめに、ストーリーを完成させたときに実行する自動テストを書く
        * 週の残りにストーリーを完成させて、自動テストをパスさせる
        * 単にテストをパスさせるのではなく、仕事に誇りを持ったチームがストーリーを完全に実装する
            * 週の終わりまでに、誰もが進捗を称賛するようなデプロイ可能なソフトウェアを作ることが目的
            * チーム（プログラマー、テスター、顧客）の仕事は、書いたテストを5日以内に実行できるようにすること

## 四半期サイクル（Quarterly Cycle）

* 四半期分の計画をまとめて立てること
* 四半期の計画では、以下のことを行う
    * ボトルネックを特定する（特にチームの外側で制御されているもの）
    * 修正作業に着手する。
    * 四半期のテーマを計画する。
    * テーマに取り組むための四半期分のストーリーを選択する。
    * プロジェクトを組織に適合させる全体像に集中する。

## ゆとり（Slack）

* どのような計画にも、遅れたときに外せるような重要度の低いタスクを含めること
* ゆとりはさまざまな方法で生み出すことができる
    * 1週間の予算の20％をプログラマーが選んだタスクにあてたりするetc

## 10分ビルド（Ten-Minute Build）

* 自動的にシステム全体をビルドして、すべてのテストを10分以内に実行させること
* プロセスが自動化されていなければ、まずはそこから手を付ける
* 次に、システムの変更した部分だけをビルドできるようにする
* 最後に、変更によってリスクが高くなった部分のテストだけを実行可能にする

## 継続的インテグレーション（Continuous Integration）

* 数時間以内に変更箇所のインテグレーションとテストをすること
* チームはプログラミングとは分割統治の問題ではなく、分割、統治、統合（インテグレーション）の問題

## テストファーストプログラミング（Test-First Programming）

```text
コードを変更する前に、失敗する自動テストを書くこと。テストファーストプログラミングは、以下のような多くの問題を一度に解決する。
```

* スコープクリープ―プログラミングに夢中になって我を忘れてしまうと、「念のため」に余計なコードを追加しがち
    * プログラムのあるべき姿を明確に客観的に記述すれば、本来のコーディングに集中できる
    * どうしてもコードを追加したいなら、手元の作業を終えたあとに別のテストを書くようにする
* 結合度と凝集度―テストを書くのが難しければ、テストの問題ではなく、設計に問題がある

## インクリメンタルな設計（Incremental Design）

* システムの設計に毎日手を入れる
* システムの設計は、その日のシステムのニーズにうまく合致させる

# 始めてみよう

* 週のはじめに1週間で達成できそうなことをすべて書き出してみる
    * やることが多すぎる場合は、チームのニーズに合わせて優先順位をつける
* 自分が維持したい価値を思い出す
* 今何をしているのか、何を達成したいのかを確認
* それから、それぞれの時間を見積もって、プロセスの改善に必要な予算を把握
* それが終わったら、最初に取り組むストーリーを選択

## プラクティスのマッピング

* プラクティスが自分とってチームにとって何を意味するかを見つける
* プラクティスについて考えるときは、思い浮かぶ懸念点をすべてマッピングする
    * 文字でも絵でも好きなやり方で構わない

# 導出プラクティス

## 本物の顧客参加（Real Customer Involvement）

* あなたのシステムによって生活やビジネスに影響を受ける人をチームの一員にすること
* 明確なビジョンを持った顧客であれば、四半期や週単位の計画づくりに参加できる
* 顧客参加のポイントは、ニーズを持つ人とそれを満たす人が直接やりとりをして、ムダな労力を減らすことである

## インクリメンタルなデプロイ（Invremental Deployment）

* レガシーシステムをリプレースするときには、プロジェクトの初期段階から少しずつ引き継ぎをすること。

## チームの継続（Team Continuity）

* 優秀なチームは継続させること
    * 大きな組織は、ヒトをモノに抽象化する傾向がある
* 要員計画の問題を単純化するためだけに、人間関係や信頼の大切さを無視するのは経済的ではない

## チームの縮小（Shrinking Teams）

* チームの能力が高まったら、仕事量を維持しながら少しずつチームの規模を縮小すること
* チームを離れた人は、また別のチームを作ることができる。チームメンバーが少なすぎる場合は、他の小さなチームと統合する
* これはトヨタ生産方式で使われているプラクティス
    * より多くの仕事量をこなすために、チームの規模を拡大するような戦略も見てきたが、それではうまくいかない。他の方法を考えるべき

## 根本原因分析（Root-Cause Analysis）

* 開発後に欠陥が見つかるたびに、欠陥とその原因を取り除くこと。
    * 欠陥の再発防止だけではなく、同じ種類の過ちをチームが二度と犯さないようにすることが目的

以下は、欠陥に対処するためのＸＰのプロセス

* 欠陥を実証するシステムレベルの自動テストを書く。そこには期待する挙動も含めておく。これは、顧客、顧客サポート、開発者が行える。
* 欠陥を再現する最小限のスコープでユニットテストを書く。
* ユニットテストが動くようにシステムを修正する。これにより、システムテストもパスするはずだ。パスしなければ、２へ戻る。
* 欠陥を修正できたら、なぜ欠陥が生み出されたのか、なぜ発見できなかったのかを見極める。

今後は同様の欠陥が再発しないように、必要な変更を加える

## コードの共有（Shared Code）

* チームの誰もが、システムのあらゆる部分をいつでも改善できる
* システムに問題があり、その修正が現在作業中のスコープの範囲内なのであれば、遠慮せずに修正すべき

## コードとテスト（Coad and Tests）

* コードとテストだけを永続的な作成物として保守すること
* その他のドキュメントについては、コードとテストから生成する
* 顧客は、システムの今日の挙動と、チームが開発する明日のシステムの挙動に対してお金を支払っている
* ソフトウェア開発における重要な意思決定は「これから何をするのか？」「これから何をしないのか？」「どのようにやるのか？」

## 単一のコードベース（Single Code Base）

* コードの流れはひとつだけである
* 一時的なブランチで開発することもできるが、数時間以上も維持してはいけない
* 複数のコードの流れは、ソフトウェア開発におけるムダの大きな原因である。

## デイリーデプロイ（Daily Deployment）

* 新しいソフトウェアを毎晩プロダクションに反映すること
    * プログラマーの手元にあるものとプロダクションにあるものが違うのはリスク
* 年末の欠陥率は数件程度でなければいけない。ビルド環境はうまく自動化されていなければいけない
* デプロイツールは、インクリメンタルな展開と、失敗時のロールバックの機能も含めて、自動化されていなければいけない
* 大規模プロジェクトには、データベースの再構成、新しいフィーチャーの実装、ユーザーインターフェイスの変更など、さまざまなタスクがある
    * システムのユーザーエクスペリエンスを変更しない限り、それ以外のあらゆるものをデプロイして構わない
    * そして、最後の日にユーザーインターフェイスという「要石」を設置する

## 交渉によるスコープ契約（Negotiated Scope Contract）

* ソフトウェア開発の契約では、期間、費用、品質を固定すること
* システムの明確なスコープについては、継続的に交渉を求めること
* 長期的なひとつの契約ではなく、短期的な契約をいくつも結ぶようにして、リスクを減らすこと

## 利用都度課金（Pay-Per-Use）

* 利用都度課金システムがあれば、システムが利用されるたびにお金を請求することができる。
* お金は究極のフィードバック

# ＸＰチーム全体

* 本当に重要なのは、誰が先頭になるかではなく全員がロープに結ばれているという感覚
* あるグループが先頭になって他のグループを追従させるよりも、全員で足並みをそろえて歩いたほうが、ずっと先まで進める

## ＸＰテスター

* ＸＰチームのテスターは、システムレベルの自動テストの選択は記述について開発前に顧客を支援したり、プログラマーにテスト技法をコーチしたりする
* 週次サイクルでは、選択したストーリーをシステムレベルの自動テストに変換するところから始める

## インタラクションデザイナー

* システム全体のメタファーを選んだり
* ストーリーを書いたり
* デプロイされたシステムの利用状況を評価して、新しいストーリーの機会を見つけたり

## アーキテクト

* 大規模リファクタリングの調査や実施をしたり
* アーキテクチャにストレスを与えるシステムレベルのテストを書いたり
* ストーリーを実装したりする
* システムの成長に合わせてアーキテクチャを追従させる

## プロジェクトマネージャー

* チーム内のコミュニケーションを円滑にしたり
* 顧客、サプライヤー、その他のチーム外の組織とのコミュニケーションを調整したりする

## プロダクトマネージャー

* ストーリーを書いたり
* 四半期サイクルのテーマやストーリーを選択したり
* 週次サイクルのストーリーを選択したり
* 実装によって明らかになったストーリーのあいまいな部分の質問に答えたりする。

## ユーザー

* ＸＰチームのユーザーは、開発中にストーリーの記述や選択の支援をしたり、専門領域の意思決定をしたりする。

## プログラマー

* ストーリーやタスクを見積もったり
* ストーリーをタスクに分解したり
* テストを書いたり
* フィーチャーを実装するコードを書いたり、退屈な開発プロセスを自動化したり、システムの設計を少しずつ改善したりする。

# 制約理論

* まずは、どの問題が開発の問題かを見極めるところから、ソフトウェア開発の改善の機会を発見する
* システム全体のスループットを見る方法のひとつに「制約理論（Theory of Constraints）」がある
    * 洗濯機が衣類を選択するのに４５分かかり、乾燥機が衣類を乾燥するのに９０分かかり、衣類を畳むのに１５分かかるとする。
    * このシステムのボトルネックは乾燥
    * 洗濯機が2台あっても、洗濯がすべて完了した衣類が増えるわけではない
    * 洗濯だけが終わった衣類は一時的に増えるかもしれないが、濡れたままの衣類が至るところに山積みになり、その対応をしなければいけなくなる
* ボトルネックを見つけるには、作業が山積みになっているところを探す

# 計画：スコープの管理

* XPでは、食料品がストーリーである
* 値札なストーリーの見積もりだ
* 予算は利用可能な時間である

以下の4つのステップを使い、あらゆるタイムスケールで計画する

* 完成させる必要がありそうな作業項目を一覧にする
* 項目を見積もる
* 計画サイクルの予算を設定する
* 予算内で完成させる作業に合意する。協議の時には見積もりや予算を変更しない

# テスト：早めに、こまめに、自動化

* 欠陥は効果的なソフトウェア開発に必要な信頼をぶち壊す。
* 顧客はソフトウェアを信頼できなければいけない。
* マネージャーは進捗情報を信頼できなければいけない。
* プログラマーはお互いに信頼できなければいけない。
* 欠陥はこうした信頼をぶち壊す。信頼できなければ、だれかが間違いを犯す可能性から自分を守ることに時間の大半を費やすだろう。

XPでは、テストのコストパフォーマンスを向上させる2つの原則を適用している。

## 「ダブルチェック」と「欠陥コストの増加」

* テストを書くときに、コンピューターにやってほしいことを伝える。
* その処理を実装するときには、同じ事を全く別の言い方で伝える。
* 2つの処理の表現が一致していれば、コードとテストが調和して、と出しくなる可能性が高い。

こまめなテストには複数の意味がある

* その一つは、間違える可能性のある本人がテストを書かなければいけないというもの
    * 欠陥の作成から検出までの感覚が数か月であれば、それぞれの活動を別々の人が担当してもおかしくない。
    * 間隔が数分だとしても、プログラマーごとに専任のテスターがいたとしても、お互いが期待していることを伝達するコストは膨大になる
* ダブルチェックの恩恵を完全に手に入れるために、XPには2セットのテストが用意されている
    * 一つは、プログラマーの視点で書かれたテスト
        * システムのコンポーネントを徹底的にテストする
    * もう一つは、顧客やユーザーの視点で書かれたテスト
        * こちらはシステム全体の操作をテストするもの
        
# XPの適用

* テストファーストプログラミングを学んでから、チームと共有する。
* チームでストーリー単位の見積もりと開発を学んでから、組織ないの顧客にスートーリーを選んでもらう。
* 組織内で安定したソフトウェアを予想どおりにデプロイすることを学んでから、組織外の顧客に計画づくりに加わってもらう。

## コーチの選択

* 「コーチ」という言葉には、チームの一員になることと、独立した視点を持つことのバランスをとる、という意味が込められている。
* 最初にコーチは、改善する箇所を特定して、それに対処するための実験をリードする。

## XPを使うべきではないとき

* XPを使っても効果がないのは、実際の価値とXPの価値が相容れない組織

# エクストリームの純度

「チームメンバーが納得できることを持続可能な方法でバイナリな（客観的な二者択一の）答えを出せることを目標にする
