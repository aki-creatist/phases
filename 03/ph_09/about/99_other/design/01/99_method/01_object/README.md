# オブジェクト指向設計

* オブジェクト指向プログラミングを設計の作業にも応用した手法
    * OOD:Object Oriented Design
* ユースケースが含まれることがある
    * ユースケースは要件定義を行うための手法だと考えればユースケースはオブジェクト指向分析の方に含まれるべきもの
* 従来の構造化設計との対比される
    * 機能を細分化する必要がある
    * 細分化の方法が構造化設計とオブジェクト指向設計では異なる
* インターフェースにより変更に強い
* 依存関係をシンプルでわかりやすくすることがシステムの保守性を高めることになる

## 処理の共通化

* 処理の共通化は、クラスの部品化やクラスの継承で実現される
* このような部品クラスを`ユーティリティクラス`と呼ぶ
    * 処理の共通化とは、`同じ処理は重複して記述しない`ということ
        * `DRY`: Don't Repeat Yourself

## インターフェイスと実装の分離

* ポリモーフィズムを使って実装の切り替えを行う
* インターフェイスとは、クラスにとっての外部仕様
* 他のクラスから呼び出す時、その外部仕様であるインターフェイスだけを知っていればメソッドを呼び出せる
* インターフェイスについて理解することが前提
    * アーキテクチャとして外部に公開するインターフェイスは何か
    * 後で説明するサブシステムやレイヤーのインターフェイスは何か
    * ユーティリティクラスのインターフェイスは何か

## ブラックボックス

* クラス間の依存関係を整理する手法
* クラス間の依存関係を整理することが、それぞれのクラスの保守性を高める
* 依存関係の整理とは`カプセル化`であり、依存関係の循環をなくすこと

## カプセル化

* オブジェクトの`内部状態をクラス内部に留める`こと
* 内部状態に依存するのはあるクラスの範囲内だけになり、ポリモーフィズムを実現可能
* 依存関係の循環とは、あるクラスの呼び出し関係が呼び出し元と呼び出し先で循環すること
* その循環を避けることにより、あるクラスを変更した時の影響範囲をシンプルにできる
* 同じことがアーキテクチャレベルで言える
    * `レイヤー`は、この依存関係を整理するための手法

## 特徴

* 構造化設計の欠点を解決するための機構
    * クラス
    * 継承
    * ポリモーフィズム
    * インスタンス化
* オブジェクト指向設計では`システムをクラスの集合`と捉え
* システムの動作は、クラス間でオブジェクトが受け渡されることで実現されると考える
    * クラス間でオブジェクトが受け渡されることを`メッッセージパッシング`と呼ぶ
* オブジェクト指向設計では、どのようなクラスかをクラス図で定義
* クラス間のメッセージパッシングをシーケンス図で定義するのが基本

## 従来との差違

構造化プログラム/オブジェクト指向プログラム

```text
//構造化プログラミングのソース

//当月カレンダー格納変数
$current_month = array();
$next_month = array();

//カレンダー変数の初期化
calender_init( $current_month );
calender_init( $next_month );

//カレンダーの生成
calender_make( $current_month, time() );
calender_make( $next_month, time() + (30 * 24 * 60 * 60 ) );
```

```text
//オブジェクト指向のソース

//カレンダークラスのインスタンス化(初期化)
$current_month = new Calender( time() );
$next_month = new Calender( time() + (30 * 24 * 60 * 60 ) );

//カレンダーの生成
$current_month->make();
$next_month->make();
```

## オブジェクト指向

* クラス: データと処理を一つの定義にしたもの
* クラスに含まれるデータを「属性」「メンバ変数」「フィールド」と呼ぶ
* 処理のことを「操作」「メソッド」と呼ぶ
    * メソッドは、構造化言語の関数に相当する

### カプセル化

* `カプセル化`
    * クラスは`フィールドを隠蔽`可能
    * クラスの`フィールドを更新するにはメソッドを呼び出す`
* カプセル化により、クラスはメソッドの`シグネチャ`だけを公開する
    * `シグネチャ`: メソッド名、引数、戻り値


### インターフェース

カプセル化によりクラスのフィールドの構造が変わっても、メソッドのシグネチャが変わらなければ、

* `インターフェイス`
    * カプセル化されたメソッドとそのシグネチャ
        * メソッドのシグネチャに変更がない限りクラスの呼び出し元には変更の影響がない

### 継承

* クラスを拡張するための機構
    * 拡張元のクラスに影響を与えずに拡張可能
* 拡張元のクラスをスーパークラスや親クラスと呼ぶ
* 拡張したクラスをサブクラスや小クラスと呼ぶ
* 継承の目的は２つ
    * オーバーライド
        * スーパークラスのメソッドをサブクラスで実装の定義を置き換えること
    * オーバーロード
        * スーパークラスのメソッドのバリエーションを増やす方法
        * スーパークラスが`持っていないメソッド`を新たに定義すること
        * スーパークラスと同じメソッド名で引数だけを変えることも可能
* 処理の共通化・再利用の手法
    * プログラミングするソースコード量が少なくて済む

### ポリモーフィズム

* メソッドの呼び出し元に影響を与えずに実装クラスを変更可能
    * クラスのインターフェイスは同じままで実装だけを変える
    * 継承の考え方をさらに進めたもの
* 呼び出し元のプログラムは同じままで、異なるクラスの実装を切り替え可能

### 設計とテスト

* テストする対象のプログラムの粒度が異なるテスト
    * 単体テスト
    * 結合テスト
    * システムテスト
* テストの品質を決めるのは設計次第
* いずれのテストケースを作成するには何が正しいプログラムの挙動なのかを知らなければならない
* 画面設計書を確認する
    * ある画面のボタンを押した時にどのような処理が行われどのような結果画面が表示されるのか

#### 単体テスト

* プログラム単位のテスト
    * クラスのメソッド単位で行う
    * 単体テストにもホワイトボックステストとブラックボックステストがある
        * ホワイトボックステスト
            * 処理に応じて条件分岐などの網羅性を担保する
        * ブラックボックステスト
            * メソッドの入力である引数の組み合わせと、出力である戻り値を評価する

#### 結合テスト

* 複数のプログラムを結合したテスト
    * クラスを結合して画面からデータベースまでの１つの機能をテスト
    * 複数の機能を連携させ、画面遷移に沿ってテスト
    * ブラックボックステストが基本

#### システムテスト

* システム全体を対象にしたテスト
    * すべてのユースケースが開発され、それらすべてを対象にテスト
    * ここの機能は単独では完成している前提に立ち、ユースケース記述に沿ってテストする
    * ブラックボックステスト
    * 業務フローがあれば、時系列に業務フローに沿って業務シミュレーション
    * パフォーマンスや非機能要件に関するテスト
   

