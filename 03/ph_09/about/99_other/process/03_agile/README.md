# アジャイル開発

## 概要

```text
イテレーション開発やコミュニケーション、オンサイト顧客、動くソフトウェア、テストを重視
設計書というドキュメントの作成を重視する必要は無くなる
```

* プログラム ＝ 正しい仕様を表現しているドキュメントの代わり
* ウォーターフォールへのアンチテーゼ
* プロセスやツールより、個人と相互作用を重視
* 包括的なドキュメントよりも、動作するソフトウェア
* 契約交渉よりも、ユーザーとの協調
* 計画に従うよりも、変化に応じる

## 構成要素

* イテレーション開発
* コミュニケーション
* オンサイト
* 動くソフトウェア
* テストを重視

## 背景

* 要件定義が変更されるリスクが不可避
    * その要件定義のリスクはユーザーが判断するのであれば、初めから仕様の変化に対応したい
* アジャイル宣言はプロセス、ツール、ドキュメント、契約、計画について言及
    * 従来の方法では、仕様変更の`リスクを押さえつけよう`としていた
    * アジャイルは、仕様変更のリスクを`受け入れよう`とする
        * 仕様変更のリスクが不可避なものなら、そのリスクを受け入れた上で、そのためには何をする必要があるのかを考える

## イテレーション開発

* 短いサイクルで小さいものを開発する
    * 短いサイクル: １つのイテレーションは２週間から３週間程度と
        * しっかりした計画や開発プロセスがなくても何とかなる
        * それくらいの規模であれば、大量のドキュメントも不要
        * 実用的なものにだけ時間を使うべき
        * `個人と相互作用(つまりコミュニケーション)`と`実際に動作するソフトェア`を重視する

## コミュニケーション

* `動いているシステム`を常にユーザーに確認してもらって意見交換可能
    * 抽象的なドキュメントを使うよりも確実
    * 実際にユーザーにシステムを使ってもらえば、ユーザーとの間で仕様の理解に齟齬が生じない

## オンサイト

* 仕様変更によるリスクを軽減の手段
* １つの機能ができたらユーザーにすぐに確認してもらう
    * 開発側がユーザーの場所に在籍
        * ユーザー企業のオフィスの一角にでも場所を借りて、開発者がそこで開発
* ユーザーに動作するシステムを使って仕様を確認してもらえる

## 動くソフトウェア

* 設計書はメンテナンスされない
    * 実装と設計書は必ずくい違うから、設計書などは書かない方が良い
* プログラミングを行えば、より正確な内容をプログラムのソースコードとして表現可能
    * ソースコードは動作できるので、設計書よりも正確
    * ソースコードからクラス図やシーケンス図をリバースエンジニアリングして作成可能
        * ツールで作ったクラス図やシーケンス図は、ツールを使用する

## テストを重視

* テストケースを作成すれば、品質を確保できる
    * 設計で品質を確保するのではなく、`プログラム自体で品質を確保`する
* テストファーストによる品質確保によって設計が不要になった

## 設計不要論

* 設計は必要であり不要でもある

### 設計不要の主張

* 外部仕様をプログラマが正確に把握すれば、設計は不要
    * 詳細設計は動かない
    * 動かないものは検証できない
    * 検証できないものを作成するのに時間をかけるよりも、動くプログラムに時間をかけるべき
* アーキテクチャ設計を行うことで、多くのアプリケーションで内部設計が不要になった
* 多くの業務アプリは、画面から入力された値をDBに登録し、DBから取り出した値を画面に表示するだけ
    * 複雑なビジネスロジックが無いので内部設計は不要
* インターフェイスをプログラミングしてからJavadocを使えば、設計書に相当するものを用意できる
* 外部仕様の詳細な検討も、ドキュメント上で行うよりも実際に動くものを見せたほうが結果的に早い
    * 画面設計に変わって実際に動く画面を作ることはそれほど難しくない
* プログラミングは最高のコミュニケーションツール

### 設計必要の主張

* 再現性
    * 設計書こそがものづくりのノウハウ
    * 設計を再利用することで、複製が可能
        * 但し、システムは一度きりの特注品を作るためのもの
* 開発者間での情報共有
    * 機能拡張や保守、メンテナンスする人への情報提供
* 外部仕様がわからなければ、何を作れば良いのかわからない

## アジャイル開発を選択する

* 開発方法論としてアジャイル開発を選択する
    * アジャイル開発は開発プロセスだけの話ではない
    * 使用する技術やプログラミングスタイルもアジャイルに合わせる必要がある
    * ソースコードは常にきれいに保つ必要がある
        * リファクタリングも適宜行う

## 設計書とソースコード

* 設計書
    * 表現の得手
        * UMLのクラス図があれば、クラスの継承関係やクラス間の関連は非常に明確
        * トップダウンでクラスの責務を設計するのには優れている
    * 表現の得手不
        * UMLは複雑なものを表現するのに必ずしも適していない
        * 複雑なものをUMLでより正確かつ詳細に記述しようとすると見にくい
* ソースコード
    * 表現の得手
        * ボトムアップでクラスの責務をプログラミングして明確にしていくことが得意

## YAGNI

* YAGNI(You Ain't Gonna Need It)
    * `今、必要でないものは作らない`
        * アジャイル開発方法論の標語の１つ
        * その部分の必要性を具体的に示すユースケースがないのに、コードベースに水ぶくれの無駄なコードを追加することになりがち
* これに従うと、アーキテクチャ設計などは不要
* アーキテクチャは、**システムの発展を予想した先行投資**

