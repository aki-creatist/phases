# ステートフル関数

* クロージャは、**自由変数**を使用した状態管理が可能

## 自由変数の性質

* 定義上`非公開`
* は自由変数へのアクセスを認める
* アクセスはスコープチェーン自体の中からのみ
    * 自由変数へのアクセスを認めるスコープチェーン(クロージャ)のみが可能
* JSでは、これ以外の方法では非公開状態は作成不可
    * Privateキーワードがないため

## 一意なIDを生成する

* 任意のオブジェクトに対して一意なIDが生成
    * オブジェクトや関数をプロパティキーとして使う
* 一意なIDは、DOM要素でも役に立つ

### プロパテイ識別子

* JSのプロパテイ識別子は、必ず強制的に文字列に変換される
    * そのため、キーがオブジェクトになっているプロパテイを設定可能
    * しかし、そのプロパテイは期待通りには動作しない

### 背景

* DOM要素のプロパテイとしてデータを格納すると、問題を引き起こす原因になる
    * メモリリークetc,,
    
### 目的

* 問題を解決するために要素のために一意なIDを生成
* 要素とは別の場所に要素関連の格納場所を管理する
    * こうすれば、要素のデータを取得、設定するAPIは、一意なIDを直接格納することを除けば、それらを直接要素に格納しなくて済む

## 実装

* ステートフルクロージャの例として、`tddjs.uid()`を実装
    * このメソッドはオブジェクトを受け付ける
    * 数値IDを返すIDは、オブジェクトのプロパテイに格納される
    
### テストの記述

* [test/uid_test.js](test/uid_test.js)
* これは、`uid()`がサポートする基本的なふるまい

### 実装

* [src/tdd.js#23](src/tdd.js#23)
* この関数にプリミティブ型の値を渡しても、期待通りには動作しない
* プリミティブにプロパティを代入しようとすると、プリミティブにプロパテイを追加するのではない
* プロパテイアクセスのためにプリミティブをオブジェクトでラップすることになる
    * しかし、そのオブジェクトはすぐに捨てられてしまう
    * つまり、`new String("mystring").__uid = 3`のようになる
* クロージャを使えば、外部からのアクセスから保護された自由変数にカウンタを格納可能

```javascript
(function () {
    var id = 0;

    //IDが要求されるたびにインクリメントされるカウンタをルックアップしてIDを生成
    function uid(object) {
        if (typeof object.__uid != "number") {
            object.__uid = id++;
        }

        return object.__uid;
    }

    if (typeof tddjs == "object") {
        tddjs.uid = uid;
    }
}());
```

* このIDは、uid関数オブジェクトのプロパテイとして格納することもできる
    * そうすると、外から変更される恐れがある
* すると、`uid()`は、仕様を破って同じIDを二度返してしまうかもしれない
* この実装は、ただちに呼び出される無名クロージャを使って、ID変数の寿命をコントロールするスコープを作る
* uid関数は、この変数にアクセスでき、tddjSuidとして外部から呼び出せるようになっている
* typeofによるテストは、何らかの理由でtddjsオブジェクトがロードされていない場合でも、参照エラーを起こさないようにするため
